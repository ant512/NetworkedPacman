EvaluationSuccesses
The system has a considerable number of successful components.  The separation of the system into distinct layers – database, database abstraction layer, client/server communication and client – insulates changes in one layer from affecting the others.  This design decision also allowed the team to work fairly independently, yet glue the sections together later with minimal effort.  The use of stub methods in the database abstraction class, for example, allowed the team to work with simulated database behaviour even though the actual database interaction was not yet written.
The communications system works exceptionally well.  It is designed to support both generic server messages and game-specific messages in such a way that the game message system is extensible.  Every game in the system can add its own set of messages without any changes being made to the server.  Removing any responsibility for co-ordinating games from the server allowed this to happen.  Games are co-ordinated by the clients themselves; the server merely starts games running, passes messages between clients, and watches for a game over condition.  It has no understanding of the games themselves, and so has no need to understand game messages, which results in a system that can support multiple types of game.
It also allows for synchronous and asynchronous communication.  Clients can request messages and block until they are received; they can request messages and continue running until they are received; or they can respond to unrequested messages.  The two games illustrate its versatility: PacMan uses asynchronous communication for a realtime game, whilst Connect 4 uses synchronous communication for a turn-based game.
Detecting unresponsive clients, or an unresponsive server, works well.  It took some experimentation to arrive at a set of values that could be used to determine if a communication node had stopped responding, which involved testing on various operating systems and computers, but the final values seem to work well.
Designing the detection routines was rather complex.  The system initially worked on a two-way system, in which clients sent “pong” messages in response to a server’s “ping” message, but it quickly became apparent that this was cumbersome and over-engineered.  The current approach is more lightweight and robust, and simply involves both client and server remembering when they last received a message.  The “ping” simply acts as a one-way “keep-alive” message.Potential Improvements
There are a number of ways in which the system could have been improved.  Firstly, since the system is designed to support multiple games, it would have been useful to have specified an interface that defined the basic functionality of a game, such as startup, shutdown, client loss detection, and so on.  This would have made it easier for third-parties to have added extra games to the client, or even created new clients that used the various packages.
In the present system, although it was designed from the outset to support multiple games, actually creating a second game was a late decision.  This is reflected in the lack of standardisation between the two.
Related to this, PacMan is implemented as a static class.  This is ideal in the situation where it is the only game, but problematic when it is just one amongst a number of games.  As a static class, it consumes resources even when the game is not active.
PacMan suffers from a few other problems which, given extra time, could also be addressed.  Players using very slow computers may find that their sprites move more slowly than the others.  This is not a synchronisation problem; it is simply due to their computers processing the game loop slower than the others, resulting in their co-ordinates being updated more slowly.  The “enemy” sprites move around at the usual speed due to the resilience of the synchronisation system.  The main culprit for this is the event-driven nature of Swing, which makes it impossible to synchronise local updates to screen refreshes or monitor vertical blank interrupts.  Testing across a number of platforms, including several distributions of Linux, OSX, Windows XP and Vista, revealed that Linux computers suffer most heavily because of the operating system’s poor graphics performance.
It would be possible to solve this by relying on the system clock to work out how long has elapsed between game refreshes, and use that delta quantity to calculate how far a sprite should have moved during that period.  That would replace the current system in which sprites are moved by a constant amount each time the game loop runs, regardless of how much time has elapsed between iterations.A second problem in PacMan is its reliance upon sound in timing events.  For example, the “PacMan lost a life” animation plays until the corresponding sound sample stops playing.  In platforms that do not support sound playback, the animation does not play, potentially causing synchronisation problems between clients.
A partial fix for this exists in the code.  The Animation class fires events when animations play, pause, stop and loop, so it would be possible to wire these events up to a listener and use that listener to control the progression of the game.  However, this is a minor issue, unless testing multiple clients on Linux computers (Java programs appear to exclusively lock the sound hardware, meaning only the first client has sound enabled).
The communications system could have been improved by using byte arrays instead of strings for message passing.   This would have resulted in optimal messages being transmitted, as delimiters would not have been needed.   However, such a system would have been harder to create from scratch in the allowed time, so the minor inconvenience of transmitting strings is outweighed by the transparency it affords in the code.
Another way to improve the communications system would have been to create a multithreaded, event-driven system instead of the polling-and-queuing system currently employed.  At present, the system relies on the Server.queueMessages() method being called as frequently as possible in order to receive and queue incoming messages from the server.  This complicates the client, as all components must ensure that they regularly call that method regardless of whatever else they are doing.  The Swing UI is a particularly unpleasant example of this, as frames must inherit from a ClientFrame class that uses a timer object to poll the queueMessages() method.
A better design would use a separate thread to automatically poll and queue incoming messages, then raise events to a list of listeners whenever a message is received.  The server implements the event system to a degree – it can raise events when it receives messages, etc, mainly to allow it to notify listeners when the server crashes.  Implementing the threading system introduced unacceptable performance issues in the games, though, which prevented it being included in the final product.
Lastly, the user interface in the final product is a considerably reduced version of the original design.  Originally, the system was designed to allow players to create their own custom game sessions – they could create new sessions, invite other players to join sessions, and join existing sessions.  Unfortunately, this functionality had to be removed due to time constraints.  Implementing the design involved far too much code in the database, server, client and user interface components and was simply impractical.